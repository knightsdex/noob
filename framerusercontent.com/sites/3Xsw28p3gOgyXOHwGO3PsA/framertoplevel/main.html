import * as Framer from "framer"; import { ResolveLinks } from "framer"; import
* as React from "react"; import { createPortal } from "react-dom"; import * as
ReactDOM from "react-dom/client"; import Default from
"../framerusercontent/sites/3Xsw28p3gOgyXOHwGO3PsA/https/framerusercontent.com/modules/8rQQqsePfX7Atvn80lDG/QIRuIM7Dg3qMxDOOSvHZ/jK69qE2N9.js";
const routes = {augiA20Il: {elements: {C01TUQU7_: "hero", n8EtdoyqS: "buy"},
page: Framer.lazy(() =>
import("../framerusercontent/sites/3Xsw28p3gOgyXOHwGO3PsA/https/framerusercontent.com/modules/tEYLF2VVg4gGZXVYfSvz/CT0LvXdRgaJsT4HxsxGR/augiA20Il.js")),
path: "/"}} const locales = [{code: "en", id: "default", name: "English", slug:
"", textDirection: "ltr"}] const collectionUtils = {} const framerSiteId =
"0a93b458f0c900544f7b586b0b8c2f3ab030d279b93674dd3fc1524421c54826" function
Template({webPageId, children, style, ...rest}) {const props1 = {EoyjD5jyL:
{href: {webPageId: "G0SiPf8O5"}}, kpmHBdXdi: {href: {webPageId: "G0SiPf8O5"}},
qPl23R2jN: {href: {webPageId: "G0SiPf8O5"}}, wcNfTqjf4: {href: {webPageId:
"G0SiPf8O5"}}} const templateProps = {augiA20Il: props1} const props =
templateProps[webPageId] ?? {} switch (webPageId) {case "augiA20Il": return
React.createElement(ResolveLinks, {links: [props["wcNfTqjf4"],
props["kpmHBdXdi"], props["qPl23R2jN"], props["EoyjD5jyL"]]}, (resolvedLinks) =>
React.createElement(Default, {...props, EoyjD5jyL: resolvedLinks[3], key:
"Default", kpmHBdXdi: resolvedLinks[1], qPl23R2jN: resolvedLinks[2], style,
wcNfTqjf4: resolvedLinks[0]}, children(true))); default: { return
children(false) }}} export function getLayoutTemplateBreakpoints(routeId)
{switch (routeId) {case "augiA20Il": return [{hash: "u2y368", mediaQuery:
"(min-width: 1200px)"}, {hash: "1dfkmv1", mediaQuery: "(min-width: 810px) and
(max-width: 1199.98px)"}, {hash: "o3985", mediaQuery: "(max-width: 809.98px)"}]
default: { return undefined }}} export async function getPageRoot({ routeId,
pathVariables, localeId }) { const rootPreload = routes[routeId].page.preload()
const content = React.createElement( Framer.PageRoot, { isWebsite: true,
routeId, pathVariables, routes, collectionUtils, framerSiteId, notFoundPage:
Framer.lazy(() => import("__framer-not-found-page")), isReducedMotion:
undefined, localeId, locales, preserveQueryParams: undefined, siteCanonicalURL:
"https://nooboneth.vip", EditorBar: typeof window !== "undefined" ? (() => {
const isBot =
/bot|-google|google-|yandex|ia_archiver|crawl|spider/iu.test(navigator.userAgent)
if (isBot) { console.log("[Framer On-Page Editing] Unavailable because navigator
is bot") return } return Framer.lazy(async () => { const dependencies = {
__version: 3, framer: { useCurrentRoute: Framer.useCurrentRoute, useLocaleInfo:
Framer.useLocaleInfo, useRouter: Framer.useRouter, }, react: { createElement:
React.createElement, Fragment: React.Fragment, memo: React.memo, useCallback:
React.useCallback, useEffect: React.useEffect, useRef: React.useRef, useState:
React.useState, useLayoutEffect: React.useLayoutEffect, }, "react-dom": {
createPortal }, } window.__framer_editorBarDependencies = dependencies const {
createEditorBar } = await import("https://framer.com/edit/init.mjs") return {
default: createEditorBar(), } }) })() : undefined , adaptLayoutToTextDirection:
false, LayoutTemplate: Template, loadSnippetsModule: new Framer.LazyValue(() =>
import("../framerusercontent/sites/3Xsw28p3gOgyXOHwGO3PsA/https/framerusercontent.com/modules/wFCyj8TAmKG7n66cPrvK/WW1NEysBdi3uEJbbHz8X/snippets.js")),
} ) const contentWithFeaturesContext = React.createElement(
Framer.LibraryFeaturesProvider, { children: content, value:
{advancedSpamProtection: true, customCodeSiteSettings: true,
editorBarDisableFrameAncestorsSecurity: false, motionDivToDiv: false,
onPageLocalizationSupport: false, onPageMoveTool: false,
synchronousNavigationOnDesktop: false, yieldOnTap: false} } ) const
contentWithGracefullyDegradingErrorBoundary =
React.createElement(Framer.GracefullyDegradingErrorBoundary, { children:
contentWithFeaturesContext }) const page =
React.createElement(Framer.PageEffectsProvider, { children:
contentWithGracefullyDegradingErrorBoundary, value: {global: {enter: {opacity:
0, rotate: 0, rotate3d: false, rotateX: 0, rotateY: 0, scale: 1, transition:
{damping: 30, delay: 0, duration: 0.2, ease: [0.27, 0, 0.51, 1], mass: 1,
stiffness: 400, type: "tween"}, x: "0px", y: "0px"}}, routes: {}} }) // We don't
want the initial render to immediately have to suspend. await rootPreload return
page } const isBrowser = typeof document !== "undefined" if (isBrowser) {
window.__framer_importFromPackage = (packageAndFilename, exportIdentifier) => ()
=> { return React.createElement(Framer.ErrorPlaceholder, { error: 'Package
component not supported: "' + exportIdentifier + '" in "' + packageAndFilename +
'"' }) } window.__framer_events = window.__framer_events || [] // Initialize
lazy modules cache for hydration Framer.initLazyModulesCache() // Fallback
support for stack gaps Framer.installFlexboxGapWorkaroundIfNeeded() const
container = document.getElementById("main") // We know that #main is parsed
before this script, so we don't need to wait for DOMContentLoaded or similar
events. if ("framerHydrateV2" in container.dataset) main(true, container) else
main(false, container) } function track() { if (!isBrowser) return
window.__framer_events.push(arguments) } async function main(shouldHydrate,
container) { function handleError(error, errorInfo, recoverable = true) { if
(error.caught || window.__framer_hadFatalError) return // we already logged it
const componentStack = errorInfo?.componentStack if (recoverable) {
console.warn("Caught a recoverable error. The site is still functional, but
might have some UI flickering or degraded page load performance. If you are the
author of this website, update external components and check recently added
custom code or code overrides to fix the following server/client mismatches:\n",
error, componentStack) // we only want to collect 1%, because this can be quite
noisy (floods the data pipeline) if (Math.random() > 0.01) return } else {
console.error("Caught a fatal error. Please report the following to the Framer
team via https://www.framer.com/contact/:\n", error, componentStack) }
track(recoverable ? "published_site_load_recoverable_error" :
"published_site_load_error", { message: String(error), componentStack, //
componentStack is more useful stack: componentStack ? undefined : error
instanceof Error && typeof error.stack === "string" ? error.stack : null, }) }
try { let routeId, localeId, pathVariables, breakpoints if (shouldHydrate) {
const routeData = JSON.parse(container.dataset["framerHydrateV2"]) routeId =
routeData.routeId localeId = routeData.localeId pathVariables =
routeData.pathVariables breakpoints = routeData.breakpoints routeId =
Framer.patchRoutesForABTesting(routes, routeId) // Prioritize optimized route id
to avoid flickering in browsers not supporting the server-timing header (Safari
older than 16.4) } else { Framer.patchRoutesForABTesting(routes, undefined) //
This must happen before inferInitialRouteFromPath const
serverRouteExperimentEnabled = false const serverRoute =
serverRouteExperimentEnabled &&
performance.getEntriesByType("navigation")[0]?.serverTiming?.find(e => e.name
=== "route")?.description if (serverRoute) { const routeData = new
URLSearchParams(serverRoute) routeId = routeData.get("id") localeId =
routeData.get("locale") for (const [key, value] of routeData.entries()) { if
(!key.startsWith("var.")) continue pathVariables ??= {}
pathVariables[key.slice(4)] = value } } if (!routeId || !localeId) { const
routeData = Framer.inferInitialRouteFromPath(routes,
decodeURIComponent(location.pathname), true, locales) routeId =
routeData.routeId localeId = routeData.localeId pathVariables =
routeData.pathVariables } } const pagePromise = getPageRoot({ routeId, localeId,
pathVariables }) if (typeof window !== "undefined") { void (async () => { const
route = routes[routeId] const defaultLocaleId = "default" const framerLocale =
locales.find(({ id }) => !localeId ? id === defaultLocaleId : id ===
localeId).code let collectionItemId = null if (route?.collectionId &&
collectionUtils) { const utils = await collectionUtils[route.collectionId]?.()
const [slug] = Object.values(pathVariables) if (utils && typeof slug ===
"string") { collectionItemId = (await utils.getRecordIdBySlug(slug, framerLocale
|| undefined)) ?? null } } const resolvedDateTimeOptions =
Intl.DateTimeFormat().resolvedOptions() const timezone =
resolvedDateTimeOptions.timeZone const locale = resolvedDateTimeOptions.locale
// wait for the page to be activated before sending the pageview event //
https://developer.chrome.com/docs/web-platform/prerender-pages#impact-on-analytics
await new Promise((resolve) => { if (document.prerendering) {
document.addEventListener("prerenderingchange", resolve, { once: true }) } else
{ resolve() } }) window.__framer_events.push([ "published_site_pageview", {
framerSiteId: framerSiteId ?? null, version: 2, routePath: route?.path || "/",
collectionItemId, framerLocale: framerLocale || null, webPageId:
route?.abTestingVariantId ?? routeId, abTestId: route?.abTestId, referrer:
document.referrer || null, url: window.location.href, hostname:
window.location.hostname || null, pathname: window.location.pathname || null,
hash: window.location.hash || null, search: window.location.search || null,
timezone, locale, }, "eager" ]) // Yield to avoid blocking the main thread with
the user code await Framer.yieldToMain({ priority: "background",
ensureContinueBeforeUnload: true, continueAfter: "paint" })
document.dispatchEvent(new CustomEvent("framer:pageview", { detail: {
framerLocale: framerLocale || null } })) })() } const page = await pagePromise
if (shouldHydrate) { Framer.withPerformanceMarks("framer-rewrite-breakpoints",
() => { Framer.removeHiddenBreakpointLayersV2(breakpoints)
window.__framer_onRewriteBreakpoints?.(breakpoints) }) const startTransition =
React.startTransition startTransition(() => { Framer.markHydrationStart() if
(true) Framer.turnOffReactEventHandling() ReactDOM.hydrateRoot(container, page,
{ onRecoverableError: handleError }) }) } else { ReactDOM.createRoot(container,
{ onRecoverableError: handleError }).render(page) } } catch (error) {
handleError(error, undefined, false) throw error } }
